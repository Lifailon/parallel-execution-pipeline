<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1540.v295eccc9778f">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@2.2258.v4e96d2b_da_f9b_"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@2.2258.v4e96d2b_da_f9b_">
      <jobProperties/>
      <triggers>
        <string>hudson.triggers.TimerTrigger</string>
      </triggers>
      <parameters>
        <string>credentials</string>
        <string>jenkinsUrl</string>
        <string>export</string>
      </parameters>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.sonyericsson.rebuild.RebuildSettings plugin="rebuild@338.va_0a_b_50e29397">
      <autoRebuild>false</autoRebuild>
      <rebuildDisabled>false</rebuildDisabled>
    </com.sonyericsson.rebuild.RebuildSettings>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <hudson.triggers.TimerTrigger>
          <spec>30 23 * * 1-6</spec>
        </hudson.triggers.TimerTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>jenkinsUrl</name>
          <description>Jenkins server address
Format: http[s]://&lt;IP/HOSTNAME&gt;:PORT.</description>
          <defaultValue>http://192.168.3.105:8080</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <com.cloudbees.plugins.credentials.CredentialsParameterDefinition plugin="credentials@1419.v2337d1ceceef">
          <name>credentials</name>
          <description>Username with password from Jenkins Credentials for API connection.</description>
          <defaultValue>15d05be6-682a-472b-9c1d-cf5080e98170</defaultValue>
          <credentialType>com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl</credentialType>
          <required>true</required>
        </com.cloudbees.plugins.credentials.CredentialsParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>export</name>
          <description>Export config in artifacts.</description>
          <defaultValue>false</defaultValue>
        </hudson.model.BooleanParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@4175.ve65b_fa_663eed">
    <script>import org.apache.http.client.methods.HttpGet
import org.apache.http.impl.client.HttpClients
import org.apache.http.util.EntityUtils
import org.apache.http.HttpHeaders
import groovy.json.JsonSlurper

// Функция для извлечения учетных данных в Pipeline
def getCred(credentials) {
    def username = &quot;&quot;
    def password = &quot;&quot;
    withCredentials([usernamePassword(
        credentialsId: credentials,
        usernameVariable: &apos;USERNAME&apos;,
        passwordVariable: &apos;PASSWORD&apos;
    )]) {
        username = env.USERNAME
        password = env.PASSWORD
    }
    return [username, password]
}

// Функция для получения списка всех jobs
def getJobs(jenkinsUrl, username, password, includeFolders = true) {
    try {
        def authString = &quot;${username}:${password}&quot;.bytes.encodeBase64().toString()
        def authHeader = &quot;Basic ${authString}&quot;
        def client = HttpClients.createDefault()
        // Запрашиваем только необходимые поля (name и class)
        // Поле class нужно для определения типа элемента (job или folder)
        def getRequest = new HttpGet(&quot;${jenkinsUrl}/api/json?tree=jobs[name,class]&quot;)
        getRequest.setHeader(HttpHeaders.AUTHORIZATION, authHeader)
        def response = client.execute(getRequest)
        try {
            def json = EntityUtils.toString(response.getEntity())
            def slurper = new JsonSlurper()
            def jobsData = slurper.parseText(json)
            def allJobs = []
            getJobsFolder(jenkinsUrl, authHeader, jobsData.jobs, allJobs, includeFolders)
            return allJobs
        } 
        finally {
            response.close()
            client.close()
        }
    }
    catch(Exception err) {
        println &quot;Error getting jobs list: ${err.message}&quot;
        return []
    }
}

// Функция для обработки вложенности jobs в директория
def getJobsFolder(baseUrl, authHeader, jobs, collector, includeFolders, currentPath = &apos;&apos;) {
    jobs.each { job -&gt;
        def fullJobName = currentPath ? &quot;${currentPath}/${job.name}&quot; : job.name
        if (job._class?.contains(&apos;Folder&apos;) &amp;&amp; includeFolders) {
            try {
                def client = HttpClients.createDefault()
                def encodedPath = job.name.split(&apos;/&apos;).collect { 
                    URLEncoder.encode(it, &apos;UTF-8&apos;).replace(&apos;+&apos;, &apos;%20&apos;) 
                }.join(&apos;/&apos;)
                def folderRequest = new HttpGet(&quot;${baseUrl}/job/${encodedPath}/api/json?tree=jobs[name,class]&quot;)
                folderRequest.setHeader(HttpHeaders.AUTHORIZATION, authHeader)
                def response = client.execute(folderRequest)
                try {
                    def json = EntityUtils.toString(response.getEntity())
                    def slurper = new JsonSlurper()
                    def folderData = slurper.parseText(json)
                    getJobsFolder(baseUrl, authHeader, folderData.jobs, collector, includeFolders, fullJobName)
                } finally {
                    response.close()
                    client.close()
                }
            } catch(Exception e) {
                println &quot;Error processing folder ${job.name}: ${e.message}&quot;
            }
        } else {
            collector &lt;&lt; fullJobName
        }
    }
}

// Основная функция для экспорта
def exportJobsConfig(jenkinsUrl, username, password, jobsList, exportPath) {
    // Формируем авторизационные данные
    def authString = &quot;${username}:${password}&quot;.bytes.encodeBase64().toString()
    def authHeader = &quot;Basic ${authString}&quot;
    // Пересоздаем директорию
    def exportDir = new File(exportPath)
    exportDir.deleteDir()
    exportDir.mkdirs()
    // Проходимся по всем конфигурациям в массиве
    jobsList.each { jobName -&gt;
        try {
            def client = HttpClients.createDefault()
            // Формируем URL для вложенных jobs
            def jobUrlPath = jobName.split(&apos;/&apos;).collect { 
                // Экранируем пробелы в пути названия jobs
                URLEncoder.encode(it, &apos;UTF-8&apos;).replace(&apos;+&apos;, &apos;%20&apos;)
            }.join(&apos;/job/&apos;)
            // Формируем URL для загрузки config.xml
            def getRequest = new HttpGet(&quot;${jenkinsUrl}/job/${jobUrlPath}/config.xml&quot;)
            // Передаем авторизационные данные в заголовки
            getRequest.setHeader(HttpHeaders.AUTHORIZATION, authHeader)
            // Читаем конфигурацию
            def response = client.execute(getRequest)
            try {
                if (response.statusLine.statusCode == 200) {
                    // Получаем содержимое config.xml
                    def configXml = EntityUtils.toString(response.getEntity())
                    // Формируем путь для сохранения и заменяем запрещенные символы в название
                    def jobPathComponents = jobName.split(&apos;/&apos;)
                    def safeFileName = jobPathComponents.last().replaceAll(&apos;[\\\\/:*?&quot;&lt;&gt;| ]&apos;, &apos;_&apos;)
                    // Создаём поддиректории
                    def targetDir = exportDir
                    if (jobPathComponents.size() &gt; 1) {
                        def subDirs = jobPathComponents[0..-2].collect { 
                            it.replaceAll(&apos;[\\\\/:*?&quot;&lt;&gt;| ]&apos;, &apos;_&apos;) 
                        }
                        targetDir = new File(exportDir, subDirs.join(File.separator))
                        targetDir.mkdirs()
                    }
                    // Создаем файл для экспорта в целевой директории
                    def exportFile = new File(targetDir, &quot;${safeFileName}.xml&quot;)
                    // Записываем содержимое в файл
                    exportFile.write(configXml)
                    println &quot;Successfully export &apos;${jobName}&apos; to ${exportFile.absolutePath}&quot;
                } else {
                    println &quot;Failed export &apos;${jobName}&apos;: HTTP ${response.statusLine.statusCode}&quot;
                }
            }
            finally {
                response.close()
                client.close()
            }
        }
        catch(Exception err) {
            println &quot;Failed export &apos;${jobName}&apos;: ${err.message}&quot;
        }
    }
}

pipeline {
    agent {
        label &apos;built-in&apos; // Jenkins Server Agent
    }
    triggers {
        cron(&apos;30 23 * * 1-6&apos;)
    }
    options {
        timeout(time: 10, unit: &apos;MINUTES&apos;)
    }
    parameters {
        string(
            name: &apos;jenkinsUrl&apos;,
            defaultValue: &apos;http://192.168.3.105:8080&apos;,
            description: &apos;Jenkins server address\nFormat: http[s]://&lt;IP/HOSTNAME&gt;:PORT.&apos;
        )
        credentials(
            name: &apos;credentials&apos;,
            description: &apos;Username with password from Jenkins Credentials for API connection.&apos;,
            credentialType: &apos;com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl&apos;,
            defaultValue: &apos;15d05be6-682a-472b-9c1d-cf5080e98170&apos;,
            required: true
        )
        booleanParam(
            name: &quot;export&quot;,
            defaultValue: false,
            description: &apos;Export config in artifacts.&apos;
        )
    }
    stages {
        stage(&apos;Backup&apos;) {
            steps {
                script {
                    if (!params.jenkinsUrl) {
                        echo &quot;Jenkins url not set&quot;
                        return
                    }
                    def creds = getCred(params.credentials)
                    def username = creds[0]
                    def password = creds[1]
                    if (!username || !password) {
                        echo &quot;Credentials not found&quot;
                        return
                    }
                    def jobsList = getJobs(params.jenkinsUrl,username,password)
                    if (!(jobsList instanceof List)) {
                        echo jobsList
                        return
                    }
                    def exportPath = &quot;&quot;
                    if (params.export) {
                        exportPath = &quot;${env.WORKSPACE}/jobs-backup/&quot;
                    } else {
                        exportPath = &quot;/var/jenkins_home/jobs-backup/&quot;
                    }
                    exportJobsConfig(params.jenkinsUrl, username, password, jobsList, exportPath)
                }
            }
        }
        stage(&apos;Export&apos;) {
            when {
                expression { params.export }
            }
            steps {
                archiveArtifacts artifacts: &quot;jobs-backup/**/*&quot;, allowEmptyArchive: true
            }
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>